---
layout: post
title: Object 01 
tags: [Object, OOP]
---

조영호님의 [오브젝트](https://wikibook.co.kr/object/)를 읽고, Study를 준비할까한다. 
최근 너무 인상깊에 읽은 책중 하나이기도했고, [코드스피츠](https://www.youtube.com/channel/UCKXBpFPbho1tp-Ntlfc25kA)에서도 강의 영상이 올라오고 있어 지금이 딱 책을 읽기 좋은 시기인것 같다 :) 


> 책을 읽기전에 명심해야 할 점 - 책 전반에서 저자가 계속해서 상기시켜주는 말 

```
은총알은 없다.
```

OOP는 은총알이 아니다. 상황에 따라 OOP 를 따를것인지, 다른 패러다임을 따를것인지 판단해야한다.



#### chap.01 

1장은 worst case 를 발전시키면서, 코드를 정리해나아가는 챕터다.  
작은 영화관 시스템을 구현하면서 OOP의 이론을 설명해나아간다. 


#### 요구사항 



````
0. 당신은 영화관을 시스템을 만들어야한다.
1. 고객은 Ticket 을 소지한 상태에서 영화관에 입장할 수 있다.
2. Tikcet 이 없다면, 판매원으로부터 티켓을 구매 후 입장해야한다.
3. event 초대장을 들고있을 경우, 티켓으로 교환하여 입장할 수 있다.
```


> 핵심 단어

`초대장` , `티켓`, `관람객`, `극장`, `티켓 판매원`


위 핵심 단어를 대상으로 class 를 만들고, 필요한 상태들을 넣는다. 
또한 class 를 만들다보면, 위 keyword 외에 아래 객체들이 추가로 생겨나게된다.

`가방`, `티켓부스`


위 개념들의 상태를 생각하면서 class 를 설계한다.


#### worst code 

`git co c880f0a9ff83d6146789ea6cfa7f4463ff610d81`


![diagram](/images/posts/oop01/diagram.png)



#### Issue 


> Robert C. Martin - Software 의 목적 

```
0. Working 
1. Comunication 
2. Simplicity 
3. Flexibility
```

대부분의 코드는 간단하게 만들면, 유연해진다. 

> 단, 요건 설계 레벨이아니라 코드 레벨에 한해서 말하는것으로 보인다.

위 Theater code 는 `Working` 만 만족할 뿐, 그 외 부분은 만족하지 못한다. 


```
public void enter(Audience audience){
	if(audience.getBag().hasInvitation()){
		Ticket ticket = ticketSeller.getTicketOffice().getTicket();
		audience.getBag().setTicket(ticket);
	}else {
		Ticket ticket = ticketSeller.getTicketOffice().getTicket();
		audience.getBag().minusAmount(ticket.getFee());
		ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
		audience.getBag().setTicket(ticket);
	}
}
```


위 코드가 난해한 이유는 각각의 객체가 *자율적이지 못하기때문*이다. 
극장이 직접 손님의 가방에서 초대장을 꺼내오거나, 판매원의 티켓과 금액을 관리하는 등, Theater가 다른 객체들의 책임의 상태를 모두 파악하고 있다. 

이렇게 각각의 객체가 수동적인 경우(`결합도가 높을경우`), 특정 객체에 변경이 일어나면 다른 객체들도 변경된다.

> 객체가 충분히 자유롭다면, 변경에 대해 자유로워진다. (응집도)



#### solution


Theater 가 구현에 의존하는게 아닌, Interface에 의존하도록 코드를 수정해야한다. 


> 간단하게 Live coding 

> feat. 훌륭한 설계는 tradeOff 의 산물이다.


#### 무엇이 바뀌었나 ?


극장이 관람객의 가방을 구현하던 부분을, 가방 스스로가 관리할 수 있도록 코드를 수정했다.

> 전까진 극장이 가방의 구현을 모두 알고있어야 했기에, 가방의 변경에 극장도 영향이 갔다.

이런 문제를 해결하기 위해, 가방 스스로가 자신을 관리하도록 수정했으며, `구현`이 아닌, `Interface` 를 통해서만 동작하도록 수정했다.
(책 내내 이야기되는 내용) 즉, 가방을 `자율적인 객체`로 만들었다.

> 현실세계의 가방은 자율적인 존재가 아니지만, OOP 세계에서의 객체는 모두 자율적인 존재여야만한다. (feat 의인화)

이렇게 객체들을 `자율적인 존재`로 바꾸다보면, 자연스럽게 결합도가 낮아지고, 응집도가 올라간다. 

> 특정 객체는 다른 객체의 구현을 전혀 알지 못할뿐더러, 단순히 Interface 로만 소통하기 때문.


#### 절차 지향 / 객체지향 


초기 코드를 보면, Theater 클래스가 모든 처리를 담당하고, 그 외 클래스들은 단순히 데이터 역할을 수행한다. 이처럼 데이터 와 함수가 분리되는 구조를 절차지향적 프로그래밍이라고 부른다. 

앞서 말했듯, 위같은 구조로 객체가 수동적인 존재가 되면, 변경에 자유롭지못한 구조로 코드가 짜여진다.

> 객체의 캡슐화가 이뤄지지 못한다.

코드를 변경에서 자유롭게 만들기위해, 데이터와 함수가 동일한 모듈 내에서 위치하도록 구조를 수정했으며, 이를 OOP 라고 부른다.


> 앞서 말했듯, 은총알은 존재하지 않는다. 상황에 맞게 코드를 작성해야한다.

```
ex ) 도메인 Layer 가 아닌 상황 (Controller / Repository / Service)는 DB에 직접적으로 연관되어 있기에 데이터를 가져와 조립하는  절차지향적으로 이뤄질 수 밖에 없다.
- 무적권으로 OOP 방식을 따라갈 순 없다.
```


#### 책임의 이동 

최초 class 를 추출하면서 이런 말을 했었다.

```
위 핵심 단어를 대상으로 class 를 만들고, 필요한 상태들을 넣는다. 
```

사실 책에서는 객체의 `상태`가 `행동`부터 설계하라고 말한다. 
상태에 초점을 맞추다보면 자연스럽게 수동적인 객체가 될 수 있다고 말하는데, 그 결과가 최초로 설계된 코드이다. 

> 상태에 초점을 맞춘 코드는 뒷장에서 더 자세한 예제로 보여준다. 

우리는 상태에 초점을 맞춘 코드를 알맞게 분리하면서, 기존에 Theater에게 많은 책임이 부여되었던 것을 각각의 객체에게 책임을 나누는 작업을 진행했다.
그 결과 변경에 변경에 닫혀있는, 견고한 코드가 완성되었다. 




2019-10-09      
lusiue@gmail.com
 
 
 
 






